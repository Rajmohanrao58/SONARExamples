package org.sonar.Jlin.java.ApiCompatibility;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.Properties;

import javax.xml.parsers.ParserConfigurationException;
import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;

import org.sonar.Jlin.java.ApiCompatibility.MessagePriority.CompatibilityRules;
//import org.apache.tools.ant.Task;
import org.xml.sax.SAXException;







/**
 * Convert messages generated by eclipse tool for compatibility checks into JLin message format.
 * This is one of the main entry points for converting messages from Eclipse API tools into SAP specific formats.
 * Known messages can be filtered out, if corresponding properties file with known errors is provided:
 * package.class$InnerClass.method(signature)_code=link to note.
 * You can also use "APICompatibility" for better integration into JLin or "MessageConverter" for additional 
 * ACH information.
 * TODO: add setter for IUsageOfAPI and initialise there.
 * DONE: As workaround for Eclipse internal error, only parts of APIs are compared at a time. This results in lots of "missing class"
 * warnings. Add switch to suppress generation of "missing type" warnings. 
 * DONE: (extra tool) generate "missing type" warnings some other way. @see com.sap.netweaver.compatibility.eclipse2jlin.ReportMissingClassesTask
 * @author d034003
 */
public class MessageConverterLocal {
	
	private File eclipseFile;
	private boolean debug = false;
	private IMessageWriter theWriter;
	private CompatibilityRules compatRules;
	private IUsageOfAPI usageOfAPI;
	private Properties knownErrors = new Properties();
	private boolean _verbose;
	private boolean _ignoreMissingClasses;
	private int numEclipseMessages;
	private int numJLinMessages;
	
	public MessageConverterLocal(){
		this(new UsageOfAPI(null, null));
		_verbose = false;
	}
	
	public MessageConverterLocal(IUsageOfAPI usage){
		eclipseFile = null;
		theWriter = null;
		compatRules = CompatibilityRules.EHP_COMPATIBILITY;
		usageOfAPI = usage;
		_ignoreMissingClasses = false;
		numEclipseMessages = 0;
		numJLinMessages = 0;
	}
	
	/**
	 * if you want, you can set your own factory for writing messages into your preferred format.
	 * @param factory
	 */
	public void initWriter(IMessageWriter writer){
		theWriter = writer;
	}
	/** 
	 * 
	 * @see org.apache.tools.ant.Task#execute()
	 */

	public void execute() {
		if (eclipseFile==null){
			throw new RuntimeException("eclipseFile name is not set.");
		}
		/*if(theWriter==null){
			throw new RuntimeException("IMessageWriter is not set.");
		}*/
		SAXParserFactory tmp = SAXParserFactory.newInstance();
		try {
			System.out.println("In Convert execute");
			//theWriter.writeHeader();
			SAXParser parser = tmp.newSAXParser();
			MessagePriority prios = new MessagePriority(compatRules);
			System.out.println("In Convert execute1");
			MessageFlags converter = new MessageFlags(prios,usageOfAPI, _ignoreMissingClasses);
			
			HandlerEclipse2JLin handler = getHandler(theWriter, converter, _verbose);
			
			parser.parse(eclipseFile, handler);
			numEclipseMessages = handler.getMessageCount();
			System.out.println(numEclipseMessages);
			
			//numJLinMessages = theWriter.getMessageCount();
			//theWriter.writeFooter();
		} catch (ParserConfigurationException e) {
			e.printStackTrace();
		} catch (SAXException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}

	}
			
	private HandlerEclipse2JLin getHandler(IMessageWriter tmp2, MessageFlags converter, boolean verbose) {
		return new HandlerEclipse2JLin(debug, 
				converter,knownErrors, verbose);
	}

	/**
	 * @param debu: if true, abort after the first 100 messages.
	 */
	public void setDebug(boolean debu){
		debug = debu;
	}
	/**
	 * @param fileName: the complete path and filename of the messages file generated by eclipse API tools.
	 * Input to this converter.
	 */
	public void setEclipseFile(String fileName){
		eclipseFile = new File(fileName);
		if (!eclipseFile.exists()){
			throw new RuntimeException("message file does not exist "+fileName);
		}
	}
	
	
	public void setCompatibilityRules(String value){
		compatRules = MessagePriority.CompatibilityRules.init(value);
	}
		
	public 	CompatibilityRules getCompatibilityRules(){
		return compatRules;
	}

	public void setVerbose(boolean value){
		this._verbose = value;
	}
	
	public void setIgnoreMissingClasses(boolean value){
		this._ignoreMissingClasses = value;
	}
	
	public void setKnownErors(File knownIncompatibilities) {
		FileInputStream inStream=null;
		try {
			inStream = new FileInputStream(knownIncompatibilities);
			knownErrors.load(inStream);
			if(_verbose){
				System.out.println("The following known errors will be ignored because they are on the exception list:");
				System.out.println(knownErrors.keySet().toString());
			}
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
		finally{
			if(inStream!=null){
				try {
					inStream.close();
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
		}
	}

	public int getEclipseMessageCount() {
		return numEclipseMessages;
	}

	public int getJLinMessageCount() {
		return numJLinMessages;
	}


}